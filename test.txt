aaahhhccccccddddddezg


Prendre premier élément dans la liste
Premier élément = élément courant
Si pour eélément courant supérieur : swap(curent/to_insert)
Si non, élément courant = élément_courant_suivant

/ Huffman_build_tree /



Element_courant = Premier élement de la liste
	Si pas de second élement
		Tree un unique noeud : return
Nouveau noeud
On     retire les deux premiers elements de la liste
nouveau_noeud->lhl = 1st element
nouveau_noeud->rhl = 2st élement
Dernier noeud = Nouveau noeud

Tant que liste pas vide,
	Curent sym = premier element de la liste
	Retirer le premier element de la liste
	Nouveau Noeud
	nouveau_noeud_lhl = ancien noeud
	nouveau_noeud->rhl = current_sym
	Ancien neoud = nouveau noeud

*Tree = ancien_noeud


/* DETAILLED TODO */

Huffman compressed file struct :
INT32 : Nb char
Huffman tree INT 32: Nb symbols
Huffman tree : code / symbol
Data 

/* TODO */
-	Test compression, Test Decompression ( MD5sum ?)
-	Test compression at different "block fixed size"
-	Idea : Adaptative compression -> Guess best size for each block from build tree infp.


