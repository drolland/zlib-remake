aaahhhccccccddddddezg


Prendre premier element dans la liste
Premier element = élément courant
Si poid element courant superieur : swap(current/to_insert)
Si non, element courant = element_courant_suivant

/ Huffman_build_tree /



Element_courant = Premier élement de la liste
	Si pas de second élement
		Tree un unique noeud : return
Nouveau noeud
On     retire les deux premiers elements de la liste
nouveau_noeud->lhl = 1st element
nouveau_noeud->rhl = 2st élement
Dernier noeud = Nouveau noeud

Tant que liste pas vide,
	Current sym = premier element de la laiste
	Retirer le premier element de la liste
	Nouveau Noeud
	nouveau_noeud_lhl = ancien noeud
	nouveau_noeud->rhl = current_sym
	Ancien neoud = nouveau noeud

*Tree = ancien_noeud


/* DETAILLED TODO */

Huffman compressed file struct :
INT32 : Nb char
Huffman tree INT 32: Nb symbols
Huffman tree : code / symbol
Data 

/* TODO */
-	Test compression, Test Decompression ( MD5sum ?)
-	Test compression at different "block fixed size"
-	Idea : Adaptative compression -> Guess best size for each block from build tree infp.
